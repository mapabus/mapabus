class BusMapApp {
  constructor(config) {
    this.map = L.map('map').setView(config.mapCenter, config.mapZoom);
    this.markersLayer = L.layerGroup().addTo(this.map);
    this.destinationLayer = L.layerGroup().addTo(this.map);
    this.routeLayers = {};
    this.colors = config.colors;
    this.directionColorMap = {};
    this.allMarkers = {};
    this.stationsMap = {};
    this.routeNamesMap = {};
    this.shapesData = {};
    this.vehicleShapeMap = {};
    this.refreshInterval = config.refreshInterval;
    this.activeRouteLayer = null;
    this.currentPopup = null;
    
    L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', {
      attribution: '&copy; CARTO, &copy; OpenStreetMap contributors',
      maxZoom: 20
    }).addTo(this.map);
    
    this.map.on('click', (e) => {
      if (e.originalEvent.target.tagName !== 'IMG' && 
          !e.originalEvent.target.closest('.leaflet-marker-icon') &&
          !e.originalEvent.target.closest('.leaflet-popup')) {
        this.clearActiveRoute();
        this.clearDestinationMarker();
      }
    });
    
    this.init();
  }

  async init() {
    await this.loadStations();
    await this.loadRouteNames();
    await this.loadShapes();
    this.loadVehicles();
  }

  async loadStations() {
    const response = await fetch('/api/stations');
    this.stationsMap = await response.json();
  }

  async loadRouteNames() {
    const response = await fetch('/route-mapping.json');
    this.routeNamesMap = await response.json();
  }

  async loadShapes() {
    if (Object.keys(this.shapesData).length > 0) {
    //  console.log('‚úì Shapes already loaded, skipping...');
      return;
    }
    try {
      const [shapesResponse, shapesGradskeResponse] = await Promise.all([
        fetch('/data/shapes.txt'),
        fetch('/data/shapes_gradske.txt')
      ]);
      
      const shapesText = await shapesResponse.text();
      const shapesGradskeText = await shapesGradskeResponse.text();
      
      this.parseShapesCSV(shapesText);
      this.parseShapesCSV(shapesGradskeText);
      
     // console.log('Shapes loaded:', Object.keys(this.shapesData).length);
    } catch (error) {
    //  console.error('Error loading shapes:', error);
    }
  }

  parseShapesCSV(csvText) {
    const lines = csvText.split('\n');
    
    for (let i = 1; i < lines.length; i++) {
      const line = lines[i].trim();
      if (!line) continue;
      
      const parts = line.split(',');
      if (parts.length < 4) continue;
      
      const shapeId = parts[0];
      const lat = parseFloat(parts[1]);
      const lon = parseFloat(parts[2]);
      const sequence = parseInt(parts[3]);
      
      if (!this.shapesData[shapeId]) {
        this.shapesData[shapeId] = [];
      }
      
      this.shapesData[shapeId].push({
        lat: lat,
        lon: lon,
        sequence: sequence
      });
    }
    
    for (let shapeId in this.shapesData) {
      this.shapesData[shapeId].sort((a, b) => a.sequence - b.sequence);
    }
  }

  async loadVehicles() {
    document.getElementById('loadingCard').classList.remove('hidden');
    
    const response = await fetch('/api/vehicles');
    const data = await response.json();
    
    document.getElementById('loadingCard').classList.add('hidden');
    
    if (data && data.vehicles) {
      const vehicleDestinations = {};
      const vehicleShapes = {};
      
      data.tripUpdates.forEach(update => {
        vehicleDestinations[update.vehicleId] = update.destination;
       
        if (update.shapeId) {
          vehicleShapes[update.vehicleId] = update.shapeId;
        }
        if (update.shape_id) {
          vehicleShapes[update.vehicleId] = update.shape_id;
        }
      });
      
      this.vehicleShapeMap = vehicleShapes;
      this.vehicleDestinations = vehicleDestinations;
      
      this.drawMarkers(data.vehicles, vehicleDestinations);
    }
  }

  drawMarkers(vehicles, vehicleDestinations) {
    this.markersLayer.clearLayers();
    this.allMarkers = {};
    
    vehicles.forEach(vehicle => {
      const routeNum = parseInt(vehicle.routeId);
      const routeDisplayName = this.getRouteDisplayName(vehicle.routeId);
      const destId = vehicleDestinations[vehicle.id] || "Unknown";
      const normalizedId = this.normalizeStopId(destId);
      const station = this.stationsMap[normalizedId];
      const destName = station ? station.name : destId;
      
      const uniqueDirKey = `${routeNum}_${destId}`;
      
      if (!this.directionColorMap[uniqueDirKey]) {
        const nextColorIndex = Object.keys(this.directionColorMap).length % this.colors.length;
        this.directionColorMap[uniqueDirKey] = this.colors[nextColorIndex];
      }
      
      const markerColor = this.directionColorMap[uniqueDirKey];
      
      let rotation = 0;
      let hasAngle = false;

      if (station && station.coords) {
        rotation = this.calculateBearing(vehicle.lat, vehicle.lon, station.coords[0], station.coords[1]);
        hasAngle = true;
      }

      const arrowDisplay = hasAngle ? 'block' : 'none';

      const iconHtml = `
        <div class="bus-wrapper">
          <div class="bus-arrow" style="transform: rotate(${rotation}deg); display: ${arrowDisplay};">
            <div class="arrow-head" style="border-bottom-color: ${markerColor}; filter: brightness(0.6);"></div>
          </div>
          <div class="bus-circle" style="background: ${markerColor};">
            ${routeDisplayName}
          </div>
          <div class="bus-garage-label">${vehicle.label}</div>
        </div>
      `;

      const customIcon = L.divIcon({
        className: 'bus-icon-container',
        html: iconHtml,
        iconSize: [50, 56],
        iconAnchor: [25, 28]
      });

      const marker = L.marker([vehicle.lat, vehicle.lon], {icon: customIcon});

      const popupContent = `
        <div class="popup-content">
          <div class="popup-row"><span class="popup-label">Linija:</span> <b>${routeDisplayName}</b></div>
          <div class="popup-row"><span class="popup-label">Vozilo:</span> ${vehicle.label}</div>
          <div class="popup-row"><span class="popup-label">Polazak:</span> ${vehicle.startTime}</div>
          <hr style="margin: 5px 0; border-color:#eee;">
          <div class="popup-row"><span class="popup-label">Smer (ide ka):</span> <span style="color:${markerColor}; font-weight:bold;">${destName}</span></div>
        </div>
      `;
      
      const popup = L.popup().setContent(popupContent);
      marker.bindPopup(popup);
      
      marker.on('click', () => {
        this.currentPopup = popup;
        this.showRouteForVehicle(vehicle.routeId, vehicle.id, markerColor);
        this.showDestinationMarker(destId, destName, markerColor);
      });
      
      this.markersLayer.addLayer(marker);
      
      this.allMarkers[vehicle.label] = {
        marker: marker,
        lat: vehicle.lat,
        lon: vehicle.lon,
        routeNum: routeNum,
        routeId: vehicle.routeId,
        routeDisplayName: routeDisplayName,
        vehicleLabel: vehicle.label,
        vehicleId: vehicle.id,
        startTime: vehicle.startTime,
        destId: destId,
        destName: destName,
        markerColor: markerColor
      };
    });
  }

  clearActiveRoute() {
    if (this.activeRouteLayer) {
      this.map.removeLayer(this.activeRouteLayer);
      this.activeRouteLayer = null;
    }
  }

  clearDestinationMarker() {
    this.destinationLayer.clearLayers();
  }

  showDestinationMarker(destId, destName, color) {
    this.clearDestinationMarker();
    
    const normalizedId = this.normalizeStopId(destId);
    const station = this.stationsMap[normalizedId];
    
    if (station && station.coords) {
      const destHtml = `
        <div class="destination-marker" style="background: ${color};">
          <div class="destination-marker-inner">üìç</div>
        </div>
      `;
      
      const destIcon = L.divIcon({
        className: 'destination-icon-container',
        html: destHtml,
        iconSize: [24, 24],
        iconAnchor: [12, 24]
      });
      
      const destPopup = `
        <div class="popup-content">
          <div class="popup-row"><span class="popup-label">Stanica:</span> <b>${destName}</b></div>
          <div class="popup-row"><span class="popup-label">ID:</span> ${destId}</div>
        </div>
      `;
      
      L.marker(station.coords, {icon: destIcon})
        .bindPopup(destPopup)
        .addTo(this.destinationLayer);
    }
  }

  showRouteForVehicle(routeId, vehicleId, color) {
    this.clearActiveRoute();
    
    const shapeIdFromVehicle = this.vehicleShapeMap[vehicleId];
    const destination = this.vehicleDestinations[vehicleId];
    
    if (shapeIdFromVehicle) {
      if (this.shapesData[shapeIdFromVehicle]) {
        this.drawRoute(shapeIdFromVehicle, color);
        return;
      }
      
      const variations = [
        shapeIdFromVehicle,
        shapeIdFromVehicle.replace(/^0+/, ''),
        shapeIdFromVehicle.padStart(shapeIdFromVehicle.length + 1, '0')
      ];
      
      for (let variation of variations) {
        if (this.shapesData[variation]) {
          this.drawRoute(variation, color);
          return;
        }
      }
      
      for (let shapeKey in this.shapesData) {
        if (shapeKey.includes(shapeIdFromVehicle) || shapeIdFromVehicle.includes(shapeKey)) {
          this.drawRoute(shapeKey, color);
          return;
        }
      }
    }
    
    let matchingShapes = [];
    for (let shapeKey in this.shapesData) {
      if (shapeKey.startsWith(routeId + '_') || shapeKey.startsWith(routeId + '-')) {
        matchingShapes.push(shapeKey);
      }
    }
    
    if (matchingShapes.length > 0) {
      let selectedShape = matchingShapes[0];
      
      if (destination && matchingShapes.length >= 2) {
        const normalizedDestination = this.normalizeStopId(destination);
        
        const destStation = this.stationsMap[normalizedDestination];
        if (destStation && destStation.coords) {
          let bestMatch = null;
          let minDistance = Infinity;
          
          matchingShapes.forEach(shapeKey => {
            const shapePoints = this.shapesData[shapeKey];
            if (shapePoints && shapePoints.length > 0) {
              const lastPoint = shapePoints[shapePoints.length - 1];
              
              const distance = this.calculateDistance(
                lastPoint.lat, lastPoint.lon,
                destStation.coords[0], destStation.coords[1]
              );
              
              if (distance < minDistance) {
                minDistance = distance;
                bestMatch = shapeKey;
              }
            }
          });
          
          if (bestMatch) {
            selectedShape = bestMatch;
          }
        } else {
          const shapeWithB = matchingShapes.find(s => s.includes('_B') || s.includes('direction_B'));
          const shapeWithA = matchingShapes.find(s => s.includes('_A') || s.includes('direction_A'));
          
          if (normalizedDestination > '10000') {
            selectedShape = shapeWithB || selectedShape;
          } else {
            selectedShape = shapeWithA || selectedShape;
          }
        }
      }
      
      this.drawRoute(selectedShape, color);
    }
  }

  drawRoute(shapeId, color) {
    const shapePoints = this.shapesData[shapeId];
    
    if (!shapePoints || shapePoints.length === 0) {
      return;
    }
    
    const latLngs = shapePoints.map(point => [point.lat, point.lon]);
    
    const polyline = L.polyline(latLngs, {
      color: color,
      weight: 4,
      opacity: 0.7,
      smoothFactor: 1
    });
    
    polyline.addTo(this.map);
    this.activeRouteLayer = polyline;
  }

  normalizeStopId(stopId) {
    if (typeof stopId === 'string' && stopId.length === 5 && stopId.startsWith('2')) {
      let normalized = stopId.substring(1);
      normalized = parseInt(normalized, 10).toString();
      return normalized;
    }
    return stopId;
  }

  normalizeRouteId(routeId) {
    if (typeof routeId === 'string') {
      return parseInt(routeId, 10).toString();
    }
    return routeId;
  }

  getRouteDisplayName(routeId) {
    const normalizedId = this.normalizeRouteId(routeId);
    return this.routeNamesMap[normalizedId] || normalizedId;
  }

  calculateBearing(startLat, startLng, destLat, destLng) {
    const y = Math.sin((destLng - startLng) * Math.PI / 180) * Math.cos(destLat * Math.PI / 180);
    const x = Math.cos(startLat * Math.PI / 180) * Math.sin(destLat * Math.PI / 180) -
              Math.sin(startLat * Math.PI / 180) * Math.cos(destLat * Math.PI / 180) * Math.cos((destLng - startLng) * Math.PI / 180);
    const brng = (Math.atan2(y, x) * 180 / Math.PI + 360) % 360;
    return brng;
  }

  calculateDistance(lat1, lon1, lat2, lon2) {
    const R = 6371e3;
    const œÜ1 = lat1 * Math.PI / 180;
    const œÜ2 = lat2 * Math.PI / 180;
    const ŒîœÜ = (lat2 - lat1) * Math.PI / 180;
    const ŒîŒª = (lon2 - lon1) * Math.PI / 180;

    const a = Math.sin(ŒîœÜ/2) * Math.sin(ŒîœÜ/2) +
            Math.cos(œÜ1) * Math.cos(œÜ2) *
            Math.sin(ŒîŒª/2) * Math.sin(ŒîŒª/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

    return R * c;
  }

  

  searchVehicles(query) {
    const resultsContainer = document.getElementById('searchResults');
    resultsContainer.innerHTML = '';
    
    if (!query || query.trim() === '') return;
    
    const searchTerm = query.toLowerCase().trim();
    const matchedVehicles = [];
    
    for (let vehicleLabel in this.allMarkers) {
      if (vehicleLabel.toLowerCase().includes(searchTerm)) {
        matchedVehicles.push(this.allMarkers[vehicleLabel]);
      }
    }
    
    const resultsToShow = matchedVehicles.slice(0, 2);
    
    resultsToShow.forEach(vehicle => {
      const resultItem = document.createElement('div');
      resultItem.className = 'search-result-item';
      resultItem.innerHTML = '<strong>Vozilo:</strong> ' + vehicle.vehicleLabel + 
                            '<br><small>Linija: ' + vehicle.routeDisplayName + '</small>';
      
      resultItem.onclick = () => {
        this.map.setView([vehicle.lat, vehicle.lon], 16);
        vehicle.marker.openPopup();
        this.showRouteForVehicle(vehicle.routeId, vehicle.vehicleId, vehicle.markerColor);
        this.showDestinationMarker(vehicle.destId, vehicle.destName, vehicle.markerColor);
        document.getElementById('searchInput').value = '';
        resultsContainer.innerHTML = '';
      };
      
      resultsContainer.appendChild(resultItem);
    });
  }
}

async function initApp() {
  const configResponse = await fetch('/api/config');
  const config = await configResponse.json();
  
  window.busApp = new BusMapApp(config);
  
  document.getElementById('searchInput').addEventListener('input', function(e) {
    window.busApp.searchVehicles(e.target.value);
  });
}
